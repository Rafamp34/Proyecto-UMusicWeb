<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>repositorios documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">repositorios documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  SearchResult</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/pages/home/home.page.ts</code>
        </p>




        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#artists" 
>
                                            artists
                                        </a>
                                </li>
                                <li>
                                        <a href="#playlists" 
>
                                            playlists
                                        </a>
                                </li>
                                <li>
                                        <a href="#songs" 
>
                                            songs
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="artists"></a>
                                        <span class="name "><b>artists</b>
                                            <a href="#artists">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>artists:         <code><a href="../interfaces/Artist.html" target="_self" >Artist[]</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../interfaces/Artist.html" target="_self" >Artist[]</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="playlists"></a>
                                        <span class="name "><b>playlists</b>
                                            <a href="#playlists">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>playlists:         <code><a href="../interfaces/Playlist.html" target="_self" >Playlist[]</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../interfaces/Playlist.html" target="_self" >Playlist[]</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="songs"></a>
                                        <span class="name "><b>songs</b>
                                            <a href="#songs">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>songs:     <code>ReactiveEnrichedSong[]</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>ReactiveEnrichedSong[]</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, Inject, OnInit, OnDestroy } from &#x27;@angular/core&#x27;;
import { Router } from &#x27;@angular/router&#x27;;
import { BehaviorSubject, catchError, forkJoin, map, Observable, of, Subject, combineLatest, debounceTime, distinctUntilChanged, switchMap } from &#x27;rxjs&#x27;;
import { Playlist } from &#x27;src/app/core/models/playlist.model&#x27;;
import { User } from &#x27;src/app/core/models/user.model&#x27;;
import { Song } from &#x27;src/app/core/models/song.model&#x27;;
import { Artist } from &#x27;src/app/core/models/artist.model&#x27;;
import { BaseAuthenticationService } from &#x27;src/app/core/services/impl/base-authentication.service&#x27;;
import { PlaylistsService } from &#x27;src/app/core/services/impl/playlists.service&#x27;;
import { SongsService } from &#x27;src/app/core/services/impl/songs.service&#x27;;
import { filter, take, takeUntil, tap, distinctUntilChanged as distinctUntilChangedOperator } from &#x27;rxjs/operators&#x27;;
import { LanguageService } from &#x27;../../core/services/language.service&#x27;;
import { UserService } from &#x27;src/app/core/services/impl/user.service&#x27;;
import { ArtistsService } from &#x27;src/app/core/services/impl/artists.service&#x27;;
import { SongEnrichmentService, EnrichedSong } from &#x27;src/app/core/services/impl/song-enrichment.service&#x27;;
import { ICollectionSubscription } from &#x27;src/app/core/services/interfaces/collection-subscription.interface&#x27;;
import { COLLECTION_SUBSCRIPTION_TOKEN } from &#x27;src/app/core/repositories/repository.tokens&#x27;;
import { EnhancedAudioPlayerService } from &#x27;src/app/core/services/impl/enhanced-audio-player.service&#x27;;
import { ToastController } from &#x27;@ionic/angular&#x27;;
import { SocialService } from &#x27;src/app/core/services/impl/social.service&#x27;;

// Interfaces para búsqueda
interface ReactiveEnrichedSong extends EnrichedSong {
  isLikedByCurrentUser: boolean;
}

interface SearchResult {
  songs: ReactiveEnrichedSong[];
  playlists: Playlist[];
  artists: Artist[];
}

interface SearchSuggestion {
  type: &#x27;song&#x27; | &#x27;playlist&#x27; | &#x27;artist&#x27;;
  id: string;
  name: string;
  subtitle?: string;
  image?: string;
}

@Component({
  selector: &#x27;app-home&#x27;,
  templateUrl: &#x27;home.page.html&#x27;,
  styleUrls: [&#x27;home.page.scss&#x27;],
})
export class HomePage implements OnInit, OnDestroy {
  isMobile: boolean &#x3D; false;
  showSearch: boolean &#x3D; false;
  currentLang: string;
  selectedTab: &#x27;all&#x27; | &#x27;music&#x27; | &#x27;podcasts&#x27; &#x3D; &#x27;all&#x27;;
  searchQuery: string &#x3D; &#x27;&#x27;;

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // PROPIEDADES DE BÚSQUEDA
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  private searchSubject &#x3D; new Subject&lt;string&gt;();
  isSearching &#x3D; false;
  showSearchResults &#x3D; false;
  searchSuggestions: SearchSuggestion[] &#x3D; [];
  searchResults: SearchResult &#x3D; {
    songs: [],
    playlists: [],
    artists: []
  };

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // PROPIEDADES EXISTENTES
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  private _quickAccess &#x3D; new BehaviorSubject&lt;Playlist[]&gt;([]);
  quickAccess$ &#x3D; this._quickAccess.asObservable();

  private _baseNewReleases &#x3D; new BehaviorSubject&lt;EnrichedSong[]&gt;([]);
  private _baseRecommendedSongs &#x3D; new BehaviorSubject&lt;EnrichedSong[]&gt;([]);

  newReleases$!: Observable&lt;ReactiveEnrichedSong[]&gt;;
  recommendedSongs$!: Observable&lt;ReactiveEnrichedSong[]&gt;;

  private _currentUser &#x3D; new BehaviorSubject&lt;User | null&gt;(null);
  currentUser$ &#x3D; this._currentUser.asObservable();

  private destroy$ &#x3D; new Subject&lt;void&gt;();

  constructor(
    private router: Router,
    public authSvc: BaseAuthenticationService,
    private playlistsSvc: PlaylistsService,
    private songsSvc: SongsService,
    private artistsSvc: ArtistsService,
    private songEnrichmentService: SongEnrichmentService,
    private languageService: LanguageService,
    private userService: UserService,
    private enhancedAudioPlayer: EnhancedAudioPlayerService,
    private toastController: ToastController,
    private socialService: SocialService,
    
    @Inject(COLLECTION_SUBSCRIPTION_TOKEN) 
    private collectionSubscriptionSvc: ICollectionSubscription&lt;Playlist&gt; &amp; ICollectionSubscription&lt;Song&gt;
  ) {
    this.currentLang &#x3D; this.languageService.getStoredLanguage();
    this.setupReactiveObservables();
    this.setupSearchObservables();
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // CONFIGURACIÓN DE OBSERVABLES
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  private setupReactiveObservables() {
    this.newReleases$ &#x3D; combineLatest([
      this._baseNewReleases.asObservable(),
      this.socialService.likedSongs$
    ]).pipe(
      map(([songs, likedSongs]) &#x3D;&gt; {
        return songs.map(song &#x3D;&gt; ({
          ...song,
          isLikedByCurrentUser: likedSongs.has(song.id)
        })) as ReactiveEnrichedSong[];
      }),
      distinctUntilChangedOperator((prev, curr) &#x3D;&gt; JSON.stringify(prev) &#x3D;&#x3D;&#x3D; JSON.stringify(curr)),
      takeUntil(this.destroy$)
    );

    this.recommendedSongs$ &#x3D; combineLatest([
      this._baseRecommendedSongs.asObservable(),
      this.socialService.likedSongs$
    ]).pipe(
      map(([songs, likedSongs]) &#x3D;&gt; {
        return songs.map(song &#x3D;&gt; ({
          ...song,
          isLikedByCurrentUser: likedSongs.has(song.id)
        })) as ReactiveEnrichedSong[];
      }),
      distinctUntilChangedOperator((prev, curr) &#x3D;&gt; JSON.stringify(prev) &#x3D;&#x3D;&#x3D; JSON.stringify(curr)),
      takeUntil(this.destroy$)
    );
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // ✅ NUEVA FUNCIONALIDAD DE BÚSQUEDA
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  /**
   * Configurar observables de búsqueda en tiempo real
   */
  private setupSearchObservables() {
    this.searchSubject.pipe(
      debounceTime(300), // Esperar 300ms después de que el usuario deje de escribir
      distinctUntilChanged(), // Solo procesar si el término cambió
      tap(term &#x3D;&gt; {
        this.isSearching &#x3D; !!term;
        this.showSearchResults &#x3D; !!term;
        
        if (!term) {
          this.clearSearchResults();
        }
      }),
      switchMap(term &#x3D;&gt; {
        if (!term || term.length &lt; 2) {
          return of(null);
        }
        
        // Realizar búsqueda en paralelo
        return this.performSearch(term);
      }),
      takeUntil(this.destroy$)
    ).subscribe({
      next: (results) &#x3D;&gt; {
        this.isSearching &#x3D; false;
        if (results) {
          this.searchResults &#x3D; results;
          this.generateSearchSuggestions(results);
        }
      },
      error: (error) &#x3D;&gt; {
        console.error(&#x27;Search error:&#x27;, error);
        this.isSearching &#x3D; false;
        this.clearSearchResults();
      }
    });
  }

  /**
   * Realizar búsqueda en tiempo real
   */
  private performSearch(term: string): Observable&lt;SearchResult&gt; {
    const searchTerm &#x3D; term.toLowerCase().trim();
    
    console.log(&#x27;Performing search for:&#x27;, searchTerm);

    return forkJoin({
      songs: this.searchSongs(searchTerm),
      playlists: this.searchPlaylists(searchTerm),
      artists: this.searchArtists(searchTerm)
    }).pipe(
      map(({ songs, playlists, artists }) &#x3D;&gt; ({
        songs,
        playlists,
        artists
      })),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Search error:&#x27;, error);
        return of({
          songs: [],
          playlists: [],
          artists: []
        });
      })
    );
  }

  /**
   * Buscar canciones
   */
  private searchSongs(term: string): Observable&lt;ReactiveEnrichedSong[]&gt; {
    return this.songsSvc.getAll(1, 10, { name: term }).pipe(
      map(response &#x3D;&gt; Array.isArray(response) ? response : response.data),
      switchMap(songs &#x3D;&gt; this.songEnrichmentService.enrichSongs(songs)),
      switchMap(enrichedSongs &#x3D;&gt; {
        // Combinar con likes del usuario
        return this.socialService.likedSongs$.pipe(
          take(1),
          map(likedSongs &#x3D;&gt; 
            enrichedSongs.map(song &#x3D;&gt; ({
              ...song,
              isLikedByCurrentUser: likedSongs.has(song.id)
            })) as ReactiveEnrichedSong[]
          )
        );
      }),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error searching songs:&#x27;, error);
        return of([]);
      })
    );
  }

  /**
   * Buscar playlists
   */
  private searchPlaylists(term: string): Observable&lt;Playlist[]&gt; {
    return this.playlistsSvc.getAll(1, 10, { name: term }).pipe(
      map(response &#x3D;&gt; Array.isArray(response) ? response : response.data),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error searching playlists:&#x27;, error);
        return of([]);
      })
    );
  }

  /**
   * Buscar artistas
   */
  private searchArtists(term: string): Observable&lt;Artist[]&gt; {
    return this.artistsSvc.getAll(1, 10, { name: term }).pipe(
      map(response &#x3D;&gt; Array.isArray(response) ? response : response.data),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error searching artists:&#x27;, error);
        return of([]);
      })
    );
  }

  /**
   * Generar sugerencias de búsqueda
   */
  private generateSearchSuggestions(results: SearchResult) {
    const suggestions: SearchSuggestion[] &#x3D; [];

    // Agregar canciones a las sugerencias
    results.songs.slice(0, 3).forEach(song &#x3D;&gt; {
      suggestions.push({
        type: &#x27;song&#x27;,
        id: song.id,
        name: song.name,
        subtitle: song.artistNames?.join(&#x27;, &#x27;) || &#x27;Unknown Artist&#x27;,
        image: song.image?.url
      });
    });

    // Agregar playlists a las sugerencias
    results.playlists.slice(0, 2).forEach(playlist &#x3D;&gt; {
      suggestions.push({
        type: &#x27;playlist&#x27;,
        id: playlist.id,
        name: playlist.name,
        subtitle: &#x60;Playlist • ${playlist.author || &#x27;Unknown&#x27;}&#x60;,
        image: playlist.image?.url
      });
    });

    // Agregar artistas a las sugerencias
    results.artists.slice(0, 2).forEach(artist &#x3D;&gt; {
      suggestions.push({
        type: &#x27;artist&#x27;,
        id: artist.id,
        name: artist.name,
        subtitle: &#x60;Artist • ${artist.followers_count || 0} followers&#x60;,
        image: artist.image?.url
      });
    });

    this.searchSuggestions &#x3D; suggestions;
  }

  /**
   * Limpiar resultados de búsqueda
   */
  private clearSearchResults() {
    this.searchResults &#x3D; {
      songs: [],
      playlists: [],
      artists: []
    };
    this.searchSuggestions &#x3D; [];
    this.showSearchResults &#x3D; false;
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // EVENTOS DE BÚSQUEDA
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  /**
   * Manejar cambio en el campo de búsqueda
   */
  onSearchChange(event: CustomEvent) {
    const term &#x3D; event.detail.value || &#x27;&#x27;;
    this.searchQuery &#x3D; term;
    this.searchSubject.next(term);
  }

  /**
   * Manejar foco en el campo de búsqueda
   */
  onSearchFocus() {
    if (this.searchQuery &amp;&amp; this.searchQuery.length &gt;&#x3D; 2) {
      this.showSearchResults &#x3D; true;
    }
  }

  /**
   * Manejar pérdida de foco (con delay para permitir clicks)
   */
  onSearchBlur() {
    setTimeout(() &#x3D;&gt; {
      this.showSearchResults &#x3D; false;
    }, 200);
  }

  /**
   * Seleccionar una sugerencia
   */
  selectSearchSuggestion(suggestion: SearchSuggestion) {
    this.searchQuery &#x3D; suggestion.name;
    this.showSearchResults &#x3D; false;

    switch (suggestion.type) {
      case &#x27;song&#x27;:
        const song &#x3D; this.searchResults.songs.find(s &#x3D;&gt; s.id &#x3D;&#x3D;&#x3D; suggestion.id);
        if (song) {
          this.openSong(song);
        }
        break;
      case &#x27;playlist&#x27;:
        const playlist &#x3D; this.searchResults.playlists.find(p &#x3D;&gt; p.id &#x3D;&#x3D;&#x3D; suggestion.id);
        if (playlist) {
          this.openPlaylist(playlist);
        }
        break;
      case &#x27;artist&#x27;:
        this.router.navigate([&#x27;/artist&#x27;, suggestion.id]);
        break;
    }
  }

  /**
   * Ir a página de resultados completos
   */
  goToFullSearchResults() {
    if (this.searchQuery.trim()) {
      this.router.navigate([&#x27;/search&#x27;], { 
        queryParams: { q: this.searchQuery.trim() } 
      });
    }
  }

  /**
   * Limpiar búsqueda
   */
  clearSearch() {
    this.searchQuery &#x3D; &#x27;&#x27;;
    this.searchSubject.next(&#x27;&#x27;);
    this.clearSearchResults();
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // MÉTODOS EXISTENTES (sin cambios)
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  ngOnInit() {
    this.checkIfMobile();
    window.addEventListener(&#x27;resize&#x27;, this.checkIfMobile.bind(this));

    this.authSvc.user$.pipe(
        filter(user &#x3D;&gt; user !&#x3D;&#x3D; undefined),
        switchMap(user &#x3D;&gt; {
            if (!user) return of(null);
            return this.userService.getById(user.id);
        }),
        takeUntil(this.destroy$)
    ).subscribe({
        next: (userData) &#x3D;&gt; {
            if (userData) {
                const updatedUser: User &#x3D; {
                    ...userData,
                    image: userData.image || undefined
                };
                this._currentUser.next(updatedUser);
            }
        },
        error: (error) &#x3D;&gt; {
            console.error(&#x27;Error loading user data:&#x27;, error);
        }
    });
  
    this.authSvc.ready$.pipe(
        filter(ready &#x3D;&gt; ready &#x3D;&#x3D;&#x3D; true),
        take(1),
        switchMap(() &#x3D;&gt; {
            return this.authSvc.authenticated$;
        }),
        take(1),
        takeUntil(this.destroy$)
    ).subscribe(isAuthenticated &#x3D;&gt; {
        if (!isAuthenticated) {
            this.router.navigate([&#x27;/login&#x27;]);
            return;
        }

        this.loadUserContent();
        this.setupCollectionSubscriptions();
    });
  }

  ngOnDestroy() {
    this.collectionSubscriptionSvc.unsubscribe(&#x27;playlists&#x27;);
    this.collectionSubscriptionSvc.unsubscribe(&#x27;songs&#x27;);
    
    this.destroy$.next();
    this.destroy$.complete();
    
    window.removeEventListener(&#x27;resize&#x27;, this.checkIfMobile.bind(this));
  }

  toggleSearch() {
    this.showSearch &#x3D; !this.showSearch;
    if (!this.showSearch) {
      this.clearSearch();
    }
  }

  changeLanguage(lang: string) {
    this.languageService.changeLanguage(lang);
    this.currentLang &#x3D; lang;
    this.languageService.storeLanguage(lang);
  }

  selectTab(tab: &#x27;all&#x27; | &#x27;music&#x27; | &#x27;podcasts&#x27;) {
    this.selectedTab &#x3D; tab;
  }

  openPlaylist(playlist: Playlist) {
    this.router.navigate([&#x27;/playlist&#x27;, playlist.id]);
  }

  async playPlaylist(playlist: Playlist, event?: Event) {
    if (event) {
      event.stopPropagation();
    }

    if (!playlist.song_IDS || playlist.song_IDS.length &#x3D;&#x3D;&#x3D; 0) {
      await this.showToast(&#x27;La playlist está vacía&#x27;, &#x27;warning&#x27;);
      return;
    }

    try {      
      const songs &#x3D; await this.getPlaylistSongs(playlist.song_IDS);
      if (songs.length &gt; 0) {
        await this.enhancedAudioPlayer.setEnrichedQueue(songs, 0);
        await this.enhancedAudioPlayer.playEnrichedSong(songs[0]);
        await this.showToast(&#x60;Reproduciendo: ${playlist.name}&#x60;, &#x27;success&#x27;);
      } else {
        await this.showToast(&#x27;No se pudieron cargar las canciones&#x27;, &#x27;danger&#x27;);
      }
    } catch (error) {
      console.error(&#x27;Error playing playlist:&#x27;, error);
      await this.showToast(&#x27;Error al reproducir la playlist&#x27;, &#x27;danger&#x27;);
    }
  }

  async openSong(song: Song | EnrichedSong) {
    try {
      await this.enhancedAudioPlayer.playEnrichedSong(song);
      await this.showToast(&#x60;Reproduciendo: ${song.name}&#x60;, &#x27;success&#x27;);
    } catch (error) {
      console.error(&#x27;Error playing song:&#x27;, error);
      await this.showToast(&#x27;Error al reproducir la canción&#x27;, &#x27;danger&#x27;);
    }
  }

  private async getPlaylistSongs(songIds: string[]): Promise&lt;Song[]&gt; {
    try {
      const songs: Song[] &#x3D; [];
      
      for (const songId of songIds) {
        try {
          const song &#x3D; await this.songsSvc.getById(songId).toPromise();
          if (song) {
            songs.push(song);
          }
        } catch (error) {
          console.error(&#x60;Error loading song ${songId}:&#x60;, error);
        }
      }
      
      return songs;
    } catch (error) {
      console.error(&#x27;Error getting playlist songs:&#x27;, error);
      return [];
    }
  }

  showAllSongs() {
    this.router.navigate([&#x27;/songs&#x27;]);
  }

  showAllRecommended() {
    this.router.navigate([&#x27;/recommended&#x27;]);
  }

  checkIfMobile() {
    this.isMobile &#x3D; window.innerWidth &lt;&#x3D; 768;
  }

  private async showToast(message: string, color: &#x27;success&#x27; | &#x27;danger&#x27; | &#x27;warning&#x27; &#x3D; &#x27;success&#x27;) {
    const toast &#x3D; await this.toastController.create({
      message,
      duration: 2000,
      color,
      position: &#x27;bottom&#x27;
    });
    await toast.present();
  }

  private setupCollectionSubscriptions() {
    // Mantener subscripciones existentes...
    this.collectionSubscriptionSvc
      .subscribe(&#x27;playlists&#x27;)
      .pipe(takeUntil(this.destroy$))
      .subscribe(change &#x3D;&gt; {
        const currentPlaylists &#x3D; this._quickAccess.value;
        
        switch (change.type) {
          case &#x27;added&#x27;:
            if (change.data &amp;&amp; !currentPlaylists.some(p &#x3D;&gt; p.id &#x3D;&#x3D;&#x3D; change.id)) {
              this._quickAccess.next([...currentPlaylists, change.data as Playlist]);
            }
            break;
          case &#x27;modified&#x27;:
            if (change.data) {
              const index &#x3D; currentPlaylists.findIndex(p &#x3D;&gt; p.id &#x3D;&#x3D;&#x3D; change.id);
              if (index !&#x3D;&#x3D; -1) {
                const updatedPlaylists &#x3D; [...currentPlaylists];
                updatedPlaylists[index] &#x3D; change.data as Playlist;
                this._quickAccess.next(updatedPlaylists);
              }
            }
            break;
          case &#x27;removed&#x27;:
            this._quickAccess.next(currentPlaylists.filter(p &#x3D;&gt; p.id !&#x3D;&#x3D; change.id));
            break;
        }
      });

    // Resto de subscripciones existentes...
  }
  
  private loadUserContent() {    
    this.authSvc.user$.pipe(
      filter(user &#x3D;&gt; user !&#x3D;&#x3D; undefined),
      take(1),
      switchMap(user &#x3D;&gt; {
        if (!user) {
          throw new Error(&#x27;No user found&#x27;);
        }

        const allSongs$ &#x3D; this.songsSvc.getAll(1, 1000, { sort: &#x27;createdAt:desc&#x27; }).pipe(
          map(response &#x3D;&gt; &#x27;data&#x27; in response ? response.data : response),
          switchMap(songs &#x3D;&gt; {
            return this.songEnrichmentService.enrichSongs(songs);
          }),
          catchError(err &#x3D;&gt; {
            return of([]);
          })
        );

        return forkJoin({
          playlists: this.playlistsSvc.getAll(1, 9, { sort: &#x27;createdAt:desc&#x27; }).pipe(
            map(response &#x3D;&gt; &#x27;data&#x27; in response ? response.data : response),
            catchError(err &#x3D;&gt; {
              return of([]);
            })
          ),
          allSongs: allSongs$
        });
      }),
      map(({ playlists, allSongs }) &#x3D;&gt; {
        const songs &#x3D; allSongs.slice(0, 8); 
        const recommendedSongs &#x3D; allSongs.slice(-8); 

        return {
          playlists,
          songs,
          recommendedSongs
        };
      })
    ).subscribe({
      next: ({ playlists, songs, recommendedSongs }) &#x3D;&gt; {
        console.log(&#x27;HomePage: Loading content:&#x27;, {
          playlistsCount: playlists.length,
          songsCount: songs.length,
          recommendedCount: recommendedSongs.length
        });
        
        this._quickAccess.next(playlists);
        this._baseNewReleases.next(songs);
        this._baseRecommendedSongs.next(recommendedSongs);
      },
      error: (error) &#x3D;&gt; {
        console.error(&#x27;HomePage: Error loading content:&#x27;, error);
      }
    });
  }

  private isSong(data: any): data is Song {
    return data 
      &amp;&amp; typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; 
      &amp;&amp; &#x27;artists_IDS&#x27; in data 
      &amp;&amp; &#x27;name&#x27; in data 
      &amp;&amp; &#x27;duration&#x27; in data;
  }

  trackBySongId(index: number, song: ReactiveEnrichedSong): string {
    return song.id;
  }

  /**
   * Obtener imagen por defecto según el tipo
   */
  getDefaultImage(type: &#x27;song&#x27; | &#x27;playlist&#x27; | &#x27;artist&#x27;): string {
    switch (type) {
      case &#x27;song&#x27;:
        return &#x27;assets/default-song.png&#x27;;
      case &#x27;playlist&#x27;:
        return &#x27;assets/default-playlist.png&#x27;;
      case &#x27;artist&#x27;:
        return &#x27;assets/default-artist.png&#x27;;
      default:
        return &#x27;assets/default-song.png&#x27;;
    }
  }

  goToAbout() {
    this.router.navigate([&#x27;/about&#x27;]);
  }

  openRepository() {
    const url &#x3D; &#x27;https://github.com/Rafamp34/Proyecto-UMusicWeb&#x27;;
    window.open(url, &#x27;_blank&#x27;);
  }

  /**
   * Obtener icono según el tipo
   */
  getTypeIcon(type: &#x27;song&#x27; | &#x27;playlist&#x27; | &#x27;artist&#x27;): string {
    switch (type) {
      case &#x27;song&#x27;:
        return &#x27;musical-note&#x27;;
      case &#x27;playlist&#x27;:
        return &#x27;list&#x27;;
      case &#x27;artist&#x27;:
        return &#x27;person&#x27;;
      default:
        return &#x27;musical-note&#x27;;
    }
  }

  /**
   * Obtener color según el tipo
   */
  getTypeColor(type: &#x27;song&#x27; | &#x27;playlist&#x27; | &#x27;artist&#x27;): string {
    switch (type) {
      case &#x27;song&#x27;:
        return &#x27;success&#x27;;
      case &#x27;playlist&#x27;:
        return &#x27;secondary&#x27;;
      case &#x27;artist&#x27;:
        return &#x27;primary&#x27;;
      default:
        return &#x27;medium&#x27;;
    }
  }

  /**
   * TrackBy function para sugerencias de búsqueda
   */
  trackBySuggestionId(index: number, suggestion: SearchSuggestion): string {
    return &#x60;${suggestion.type}-${suggestion.id}&#x60;;
  }

  /**
   * Exponer router para uso en template
   */
  get routerPublic() {
    return this.router;
}
}</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'SearchResult.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
